{"id":345335607,"lang":"python3","time":"1 year, 1 month","timestamp":1590568707,"status_display":"Output Limit Exceeded","runtime":"N/A","url":"/submissions/detail/345335607/","is_pending":"Not Pending","title":"Possible Bipartition","memory":"N/A","code":"from collections import defaultdict, deque\nclass Solution:\n    def possibleBipartition(self, N, dislikes):\n        graph = defaultdict(list)\n        for u, v in dislikes:\n            graph[u-1].append(v-1)\n            graph[v-1].append(u-1)\n        color_arr = [0] * N\n        for i in range(N):\n            if color_arr[i] == 1 or color_arr[i] == -1:\n                continue\n            queue = deque([(i, 0)])\n            while queue:\n                v, prev = queue.popleft()\n                print(v, prev)\n                if prev == 0 or prev == -1:\n                    color_arr[v] = 1\n                else:\n                    color_arr[v] = -1\n                for nv in graph[v]:\n                    if color_arr[nv] == 0:\n                        queue.append((nv, color_arr[v]))\n                    elif color_arr[nv] == color_arr[v]:\n                        print(color_arr)\n                        return False\n        \n        return True\n\n","compare_result":"111111111111111111111111111111111111111111111111111111110000000000","title_slug":"possible-bipartition"}