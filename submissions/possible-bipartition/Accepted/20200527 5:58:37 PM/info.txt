{"id":345340497,"lang":"python3","time":"1 year, 1 month","timestamp":1590569917,"status_display":"Accepted","runtime":"776 ms","url":"/submissions/detail/345340497/","is_pending":"Not Pending","title":"Possible Bipartition","memory":"19.2 MB","code":"class Solution:\n    def dfs(self, v, prev_color):\n        if not self.ans:\n            return\n        if prev_color == 0 or prev_color == -1:\n            self.color_arr[v] = 1\n        else:\n            self.color_arr[v] = -1\n        for nv in self.graph[v]:\n            if self.color_arr[nv] == 0:\n                self.dfs(nv, self.color_arr[v])\n            elif self.color_arr[nv] == self.color_arr[v]:\n                self.ans = False\n                \n    def possibleBipartition(self, N, dislikes):\n        self.graph = defaultdict(list)\n        self.ans = True\n        for u, v in dislikes:\n            self.graph[u-1].append(v-1)\n            self.graph[v-1].append(u-1)\n        self.color_arr = [0] * N\n        for i in range(N):\n            if self.color_arr[i] == 1 or self.color_arr[i] == -1 or not self.ans:\n                continue\n            self.dfs(i, 0)\n        return self.ans\n\n","compare_result":"111111111111111111111111111111111111111111111111111111111111111111","title_slug":"possible-bipartition"}