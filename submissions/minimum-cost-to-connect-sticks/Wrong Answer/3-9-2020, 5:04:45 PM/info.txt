{"id":310838190,"lang":"python3","time":"1 year, 4 months","timestamp":1583741085,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/310838190/","is_pending":"Not Pending","title":"Minimum Cost to Connect Sticks","memory":"N/A","code":"class SegSumTree:\n    \n    def __init__(self, nums):\n        if len(nums)>0:\n            self.length = len(nums)\n            self.tree = [0 for _ in range(2*self.length)]\n            \n            # build tree \n            n = self.length\n            i = n\n            j = 0\n            while i<2*n:\n                self.tree[i] = nums[j]\n                i += 1\n                j += 1\n            for i in range(n-1, 0, -1):\n                self.tree[i] = self.tree[i*2] + self.tree[i*2 + 1]\n\n    def update(self, pos, val):\n        # 0 <= pos < n\n        n = self.length\n        pos += n\n        self.tree[pos] = val\n        while (pos > 0):\n            left = pos\n            right = pos\n            if pos%2==0:\n                right = pos + 1\n            else:\n                left = pos - 1\n            self.tree[pos//2] = self.tree[left] + self.tree[right]\n            pos //= 2\n        \n    def sumRange(self, l, r):\n        if l > r:\n            l, r = r, l\n        # 0 <= l,r < n\n        n = self.length\n        l += n\n        r += n\n        res = 0\n        while l<=r:\n            # check l is right child\n            if l%2==1:\n                res += self.tree[l]\n                l += 1\n            # check r is left child\n            if r%2==0:\n                res += self.tree[r]\n                r -= 1\n            l //= 2\n            r //= 2\n        return res\n    \n    \nclass Solution:\n    def connectSticks(self, sticks):\n        seg_tree = SegSumTree(sticks)\n        N = len(sticks)\n        self.memo = [[-1 for _ in range(N)] for __ in range(N)]\n        for l in range(N):\n            for r in range(N):\n                if l == r: self.memo[l][r] = 0\n                if r - l == 1: self.memo[l][r] = sticks[l] + sticks[r]\n\n        def dp(l, r):\n            if self.memo[l][r] != -1:\n                return self.memo[l][r]\n            ans = float('inf')\n            for i in range(l, r+1):\n                if i == l:\n                    val = sticks[l] + seg_tree.sumRange(l+1, r) + dp(l+1, r)\n                elif i == r:\n                    val = seg_tree.sumRange(l, r-1) + dp(l, r-1) + sticks[r]\n                else:\n                    # tmp_val = seg_tree.sumRange(l, i-1) + dp(l, i-1) + sticks[i] + seg_tree.sumRange(i+1, r) + dp(i+1, r)\n                    dpcost = dp(l, i-1) + dp(i+1, r)\n                    intg_cost = min( \n                        (seg_tree.sumRange(l, i-1) + sticks[i]) * 2 + seg_tree.sumRange(i+1, r), \n                        seg_tree.sumRange(l, i-1) + (sticks[i] + seg_tree.sumRange(i+1, r)) * 2,\n                        (seg_tree.sumRange(l, i-1) + seg_tree.sumRange(i+1, r)) * 2 + sticks[i]\n                    ) \n                    val = dpcost + intg_cost\n                ans = min(ans, val)\n                self.memo[l][r] = ans\n            return ans\n                \n        res = dp(0, N-1)\n        return res\n        \n                    \n\n\n        ","compare_result":"10111000000000000000000000000","title_slug":"minimum-cost-to-connect-sticks"}