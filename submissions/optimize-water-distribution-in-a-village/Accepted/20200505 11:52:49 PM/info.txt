{"id":334817129,"lang":"python3","time":"1 year, 2 months","timestamp":1588690369,"status_display":"Accepted","runtime":"560 ms","url":"/submissions/detail/334817129/","is_pending":"Not Pending","title":"Optimize Water Distribution in a Village","memory":"19.2 MB","code":"from collections import defaultdict\nimport heapq\n\nclass UnionFind():\n    def __init__(self, N):\n        self.node2par = {i:i for i in range(N)}\n        self.rank = {i:0 for i in range(N)}\n        self.count = N\n\n    def find_par(self, x):\n        if self.node2par[x] != x:\n            x = self.find_par(self.node2par[x])\n        return x\n\n    def unite(self, x, y):\n        x, y = self.find_par(x), self.find_par(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.node2par[x] = y\n        else:\n            self.node2par[y] = x\n        if self.rank[x] == self.rank[y]:\n            self.rank[x] += 1\n        self.count -= 1\n\n\nclass Solution:\n    def minCostToSupplyWater(self, n, wells, pipes):\n        graph = defaultdict(list)\n        uf = UnionFind(n+1)\n        min_heap = []\n        heapq.heapify(min_heap)\n        for i, w in enumerate(wells):\n            heapq.heappush(min_heap, (w, 0, i+1))\n        for u, v, w in pipes:\n            heapq.heappush(min_heap, (w, u, v))\n        \n        ans = 0\n        while 1 < uf.count and min_heap:\n            w, u, v = heapq.heappop(min_heap)\n            if uf.find_par(u) != uf.find_par(v):\n                uf.unite(u, v)\n                ans += w\n        return ans\n\n\n\n\n        ","compare_result":"1111111111111111111111111111111111111","title_slug":"optimize-water-distribution-in-a-village"}