{"id":315421347,"lang":"python3","time":"1 year, 3 months","timestamp":1585028450,"status_display":"Accepted","runtime":"656 ms","url":"/submissions/detail/315421347/","is_pending":"Not Pending","title":"Lowest Common Ancestor of a Binary Tree","memory":"85.8 MB","code":"from copy import deepcopy\n\nclass Solution:\n    def lowestCommonAncestor(self, root, p, q):\n        pv, qv = p.val, q.val\n        self.dic = {pv:[], qv:[]}\n        def backtrack(target, node=root, current=[(root, root.val)]):\n            if len(self.dic[target]) == 1:\n                return\n            elif node.val == target:\n                self.dic[target].append(deepcopy(current))\n            else:\n                if node.left:\n                    current.append((node.left, node.left.val))\n                    backtrack(target, node.left, current)\n                    current.pop()\n                if node.right:\n                    current.append((node.right, node.right.val))\n                    backtrack(target, node.right, current)\n                    current.pop()\n\n        backtrack(target=pv)\n        backtrack(target=qv)\n        \n        p_list, q_list = self.dic[pv][0], self.dic[qv][0]\n        N = min(len(p_list), len(q_list))\n        i = 0\n        ans = root\n        while i < N:\n            if p_list[i][1] == q_list[i][1]:\n                ans = p_list[i][0]\n                i += 1\n            else:\n                break\n\n        return ans\n","compare_result":"1111111111111111111111111111111","title_slug":"lowest-common-ancestor-of-a-binary-tree"}