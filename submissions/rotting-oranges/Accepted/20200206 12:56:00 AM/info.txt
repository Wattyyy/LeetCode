{"id":300497505,"lang":"python3","time":"1 year, 5 months","timestamp":1580918160,"status_display":"Accepted","runtime":"216 ms","url":"/submissions/detail/300497505/","is_pending":"Not Pending","title":"Rotting Oranges","memory":"13.1 MB","code":"# https://leetcode.com/problems/rotting-oranges/\n\nclass Solution:\n    def orangesRotting(self, grid):\n        R, C = len(grid), len(grid[0])\n        time_grid = [[float(\"inf\") if grid[r][c]==1 else 0 for c in range(C)] for r in range(R)]\n        for r in range(R):\n            for c in range(C):\n                if grid[r][c] != 2:\n                    continue\n                visited = set((r, c))\n                queue = [(r, c)]\n                while queue:\n                    row, col = queue.pop(0)\n                    time = time_grid[row][col]\n                    vy = [1, -1, 0, 0]\n                    vx = [0, 0, 1, -1]\n                    for i in range(4):\n                        y = row + vy[i]\n                        x = col + vx[i]\n                        if (0<=y and y<R) and (0<=x and x<C) and (grid[y][x]!=0) and ((y, x) not in visited):\n                            queue.append((y, x))\n                            time_grid[y][x] = min(time_grid[y][x], time+1)\n                            print(time_grid[y][x])\n                            visited.add((y, x))\n\n        res = 0\n        for r in range(R):\n            for c in range(C):\n                res = max(res, time_grid[r][c])\n        if res == float(\"inf\"):\n            return -1\n        else:\n            return res\n                        \n                \n                \n        ","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"rotting-oranges"}