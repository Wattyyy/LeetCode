{"id":512487840,"lang":"rust","time":"2 weeks, 5 days","timestamp":1624526665,"status_display":"Accepted","runtime":"12 ms","url":"/submissions/detail/512487840/","is_pending":"Not Pending","title":"Out of Boundary Paths","memory":"2.5 MB","code":"impl Solution {\n    pub fn find_paths(m: i32, n: i32, max_move: i32, start_row: i32, start_column: i32) -> i32 {\n        let modulo = 1000000007;\n        let mut dp: Vec<Vec<Vec<i32>>> = vec![vec![vec![0; (max_move+1) as usize]; n as usize]; m as usize];\n        for mv in 1..max_move+1 {\n            for r in 0..m {\n                for c in 0..n{\n                    let nrs: [i32; 4] = [r-1, r+1, r, r];\n                    let ncs: [i32; 4] = [c, c, c-1, c+1];\n                    for i in 0..4{\n                        let nr = nrs[i];\n                        let nc = ncs[i];\n                        if 0 <= nr && nr < m && 0 <= nc && nc < n {\n                            dp[r as usize][c as usize][mv as usize] += dp[nr as usize][nc as usize][(mv - 1) as usize];\n                        }\n                        else {\n                            dp[r as usize][c as usize][mv as usize] += 1;\n                        }\n                        dp[r as usize][c as usize][mv as usize] %= modulo;\n                    }\n                    \n                }\n            }\n        }\n        return dp[start_row as usize][start_column as usize][max_move as usize] % modulo\n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"out-of-boundary-paths"}