// https://leetcode.com/problems/maximum-sum-bst-in-binary-tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

import sys
sys.setrecursionlimit(10 ** 6)
class Solution:
    def maxSumBST(self, root):
        if not root:
            return 0
        self.ans = 0
        def dp(node, l_lim, u_lim):
            # @returns -> BST_sum, is_BST         
            if not node.left and not node.right:
                self.ans = max(self.ans, node.val)
                return node.val, True
                
            elif node.left and not node.right:
                l_sum, is_bst = dp(node.left, l_lim, node.val)
                if is_bst and node.left.val < node.val and l_lim < node.val and node.val < u_lim:
                    self.ans = max(self.ans, l_sum + node.val)
                    return l_sum + node.val, True 
                else:
                    return 0, False
        
            elif not node.left and node.right:
                r_sum, is_bst = dp(node.right, node.val, u_lim)
                if is_bst and node.val < node.right.val and l_lim < node.val and node.val < u_lim:
                    self.ans = max(self.ans, r_sum + node.val)
                    return r_sum + node.val, True 
                else:
                    return 0, False
            
            else:
                l_sum, l_is_bst = dp(node.left, l_lim, node.val)
                r_sum, r_is_bst = dp(node.right, node.val, u_lim)
                if l_is_bst and r_is_bst and node.left.val < node.val and node.val < node.right.val and l_lim < node.val and node.val < u_lim:
                    self.ans = max(self.ans, l_sum + node.val + r_sum)
                    return l_sum + node.val + r_sum, True 
                else:
                    return 0, False
            
        dp(root, -float('inf'), float('inf'))
        return self.ans
                
                
            
        