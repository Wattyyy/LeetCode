{"id":466334044,"lang":"python3","time":"4Â months","timestamp":1615445211,"status_display":"Accepted","runtime":"5204 ms","url":"/submissions/detail/466334044/","is_pending":"Not Pending","title":"Min Cost to Connect All Points","memory":"79.8 MB","code":"import heapq\n\nclass UnionFind:\n    def __init__(self, N):\n        self.node2parent = {i: i for i in range(N)}\n        self.rank = {i: 0 for i in range(N)}\n        self.count = N\n    \n    def find_parent(self, x):\n        parent = self.node2parent[x]\n        if parent != x:\n            return self.find_parent(parent)\n        else:\n            return parent\n    \n    def unite(self, x, y):\n        x, y = self.find_parent(x), self.find_parent(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.node2parent[x] = y\n        else:\n            self.node2parent[y] = x\n        if self.rank[x] == self.rank[y]:\n            self.rank[x] += 1\n        self.count -= 1\n\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) == 1:\n            return 0\n        N = len(points)\n        uf = UnionFind(N)\n\n        min_heap = []\n        for i in range(N):\n            for j in range(i + 1, N):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                dist = abs(x1 - x2) + abs(y1 - y2)\n                heapq.heappush(min_heap, (dist, i, j))\n\n        ret = 0\n        while min_heap:\n            val, node1, node2 = heapq.heappop(min_heap)\n            if uf.find_parent(node1) != uf.find_parent(node2):\n                uf.unite(node1, node2)\n                ret += val\n\n        return ret            \n            ","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"min-cost-to-connect-all-points"}