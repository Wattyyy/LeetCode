{"id":479641895,"lang":"python3","time":"3Â months","timestamp":1618214595,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/479641895/","is_pending":"Not Pending","title":"Path with Maximum Probability","memory":"N/A","code":"from collections import defaultdict\nimport heapq\n\nclass Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        graph = defaultdict(list)\n        for i, (u, v) in enumerate(edges):\n            prob = succProb[i]\n            graph[u].append((v, prob))\n            graph[v].append((u, prob))\n        dist = [0.0] * n\n        dist[start] = 1.0\n        max_heap = [(-1.0, start)]\n        visited = set()\n        while max_heap:\n            if len(visited) == n:\n                break\n            val, node = heapq.heappop(max_heap)\n            dist[node] = abs(val)\n            visited.add(node)\n            for nv, prob in graph[node]:\n                if (dist[nv] < abs(val) * prob) and (nv not in visited):\n                    dist[nv] = abs(val) * prob\n                    heapq.heappush(max_heap, (-1 * abs(val) * prob, nv))\n\n        return dist[end]\n\n        \n        ","compare_result":"1111111111101110","title_slug":"path-with-maximum-probability"}