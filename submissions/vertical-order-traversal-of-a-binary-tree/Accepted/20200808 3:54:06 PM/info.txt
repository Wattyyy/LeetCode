{"id":377755777,"lang":"python3","time":"11 months, 1 week","timestamp":1596869646,"status_display":"Accepted","runtime":"32 ms","url":"/submissions/detail/377755777/","is_pending":"Not Pending","title":"Vertical Order Traversal of a Binary Tree","memory":"14.1 MB","code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        node_list = []\n\n        def BFS(root):\n            queue = deque([(root, 0, 0)])\n            while queue:\n                node, row, column = queue.popleft()\n                if node is not None:\n                    node_list.append((column, row, node.val))\n                    queue.append((node.left, row + 1, column - 1))\n                    queue.append((node.right, row + 1, column + 1))\n\n        # step 1). construct the global node list, with the coordinates\n        BFS(root)\n\n        # step 2). sort the global node list, according to the coordinates\n        node_list.sort()\n\n        # step 3). retrieve the sorted results partitioned by the column index\n        ret = OrderedDict()\n        for column, row, value in node_list:\n            if column in ret:\n                ret[column].append(value)\n            else:\n                ret[column] = [value]\n\n        return ret.values()","compare_result":"111111111111111111111111111111","title_slug":"vertical-order-traversal-of-a-binary-tree"}