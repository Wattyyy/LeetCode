// https://leetcode.com/problems/global-and-local-inversions

class Node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.l_nodes = 0
        
class BST:
    def __init__(self, val):
        self.root = Node(val)

    def add_and_count(self, val):
        cur = self.root
        ret = 0
        while cur:
            if cur.val < val:
                ret += cur.l_nodes + 1
                if cur.right:
                    cur = cur.right
                else:
                    cur.right = Node(val)
                    break
            else:
                cur.l_nodes += 1
                if cur.left:
                    cur = cur.left
                else:
                    cur.left = Node(val)
                    break
        return ret



class Solution:
    def isIdealPermutation(self, A):
        N = len(A)

        # count local inversion
        local_inv = 0
        for i in range(N):
            if i == N - 1:
                break
            if A[i] > A[i+1]:
                local_inv += 1

        # count global inversion
        global_inv = 0
        bst = BST(A[-1])
        for i in reversed(range(N-1)):
            global_inv += bst.add_and_count(A[i])
            if global_inv > local_inv:
                return False
        return global_inv == local_inv
            
    
