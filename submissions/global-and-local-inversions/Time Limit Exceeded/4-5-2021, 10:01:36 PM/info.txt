{"id":476783683,"lang":"python3","time":"3 months, 1 week","timestamp":1617627696,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/476783683/","is_pending":"Not Pending","title":"Global and Local Inversions","memory":"N/A","code":"class Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.l_nodes = 0\n        \nclass BST:\n    def __init__(self, val):\n        self.root = Node(val)\n\n    def add_and_count(self, val):\n        cur = self.root\n        ret = 0\n        while cur:\n            if cur.val < val:\n                ret += cur.l_nodes + 1\n                if cur.right:\n                    cur = cur.right\n                else:\n                    cur.right = Node(val)\n                    break\n            else:\n                cur.l_nodes += 1\n                if cur.left:\n                    cur = cur.left\n                else:\n                    cur.left = Node(val)\n                    break\n        return ret\n\n\n\nclass Solution:\n    def isIdealPermutation(self, A):\n        N = len(A)\n\n        # count local inversion\n        local_inv = 0\n        for i in range(N):\n            if i == N - 1:\n                break\n            if A[i] > A[i+1]:\n                local_inv += 1\n\n        # count global inversion\n        global_inv = 0\n        bst = BST(A[-1])\n        for i in reversed(range(N-1)):\n            global_inv += bst.add_and_count(A[i])\n            if global_inv > local_inv:\n                return False\n        return global_inv == local_inv\n            \n    \n","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000000000000000000000000000000000000000","title_slug":"global-and-local-inversions"}