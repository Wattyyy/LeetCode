{"id":497465575,"lang":"python3","time":"1 month, 2 weeks","timestamp":1621835653,"status_display":"Accepted","runtime":"760 ms","url":"/submissions/detail/497465575/","is_pending":"Not Pending","title":"Find the Shortest Superstring","memory":"15.8 MB","code":"class Solution(object):\n    def shortestSuperstring(self, A):\n        N = len(A)\n\n        # Populate graph\n        graph = [[0 for _ in range(N)] for __ in range(N)]\n        for i, x in enumerate(A):\n            for j, y in enumerate(A):\n                if i == j:\n                    continue\n                for val in range(min(len(x), len(y)), -1, -1):\n                    if x.endswith(y[:val]):\n                        graph[i][j] = val\n                        break\n\n        # dp[mask][i] = most overlap with mask, ending with ith element\n        dp = [[0 for _ in range(N)] for __ in range(1<<N)]\n        parent = [[None for _ in range(N)] for __ in range(1<<N)]\n        for mask in range(1, 1 << N):\n            for bit in range(N):\n                if (mask >> bit) & 1:\n                    # Let's try to find dp[mask][bit].  Previously, we had\n                    # a collection of items represented by pmask.\n                    pmask = mask ^ (1 << bit)\n                    if pmask == 0: continue\n                    for i in range(N):\n                        if (pmask >> i) & 1:\n                            # For each bit i in pmask, calculate the value\n                            # if we ended with word i, then added word 'bit'.\n                            value = dp[pmask][i] + graph[i][bit]\n                            if value > dp[mask][bit]:\n                                dp[mask][bit] = value\n                                parent[mask][bit] = i\n\n        # Answer will have length sum(len(A[i]) for i) - max(dp[-1])\n        # Reconstruct answer:\n\n        # Follow parents down backwards path that retains maximum overlap\n        perm = []\n        mask = (1<<N) - 1\n        i = max(range(N), key = dp[-1].__getitem__)\n        while i is not None:\n            perm.append(i)\n            mask, i = mask ^ (1<<i), parent[mask][i]\n\n        # Reverse path to get forwards direction; add all remaining words\n        perm = perm[::-1]\n        seen = [False] * N\n        for x in perm:\n            seen[x] = True\n        perm.extend([i for i in range(N) if not seen[i]])\n\n        # Reconstruct answer given perm = word indices in left to right order\n        ans = [A[perm[0]]]\n        for i in range(1, len(perm)):\n            overlap = graph[perm[i-1]][perm[i]]\n            ans.append(A[perm[i]][overlap:])\n\n        return \"\".join(ans)","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-the-shortest-superstring"}