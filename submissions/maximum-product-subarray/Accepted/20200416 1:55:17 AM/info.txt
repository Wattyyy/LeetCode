{"id":325235220,"lang":"python3","time":"1 year, 2 months","timestamp":1586969717,"status_display":"Accepted","runtime":"116 ms","url":"/submissions/detail/325235220/","is_pending":"Not Pending","title":"Maximum Product Subarray","memory":"13.9 MB","code":"import sys\nsys.setrecursionlimit(10 ** 6)\n\nclass Solution:\n    def merge(self, l, m, r, nums):\n        l_min, l_max = 0, 0\n        l_prod = 1\n        for i in reversed(range(l, m + 1)):\n            l_prod *= nums[i]\n            l_min = min(l_prod, l_min)\n            l_max = max(l_prod, l_max)\n        \n        r_min, r_max = 0, 0\n        r_prod = 1\n        for i in range(m + 1, r + 1):\n            r_prod *= nums[i]\n            r_min = min(r_prod, r_min)\n            r_max = max(r_prod, r_max)\n        \n        res = max(l_min * r_min, l_max * r_max)\n        return res\n            \n        \n        \n    def divide_and_conquer(self, l, r, nums):\n        if l == r:\n            return nums[l]\n        m = (l + r) // 2\n        l_val = self.divide_and_conquer(l, m, nums)\n        r_val = self.divide_and_conquer(m+1, r, nums)\n        merge_val = self.merge(l, m, r, nums)\n        return max(l_val, r_val, merge_val)\n        \n    def maxProduct(self, nums):\n        if not nums:\n            return 0\n        res = self.divide_and_conquer(0, len(nums)-1, nums)\n        return res","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"maximum-product-subarray"}