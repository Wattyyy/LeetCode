{"id":263206297,"lang":"python3","time":"1 year, 9 months","timestamp":1569171275,"status_display":"Accepted","runtime":"64 ms","url":"/submissions/detail/263206297/","is_pending":"Not Pending","title":"Redundant Connection","memory":"14.5 MB","code":"class UnionFind():\n    def __init__(self, N):\n        self.node2par = {i:i for i in range(1, N+1)}\n        self.rank = {i:0 for i in range(1, N+1)}\n        self.count = N\n\n    def find_par(self, x):\n        if self.node2par[x]==x:\n            return x\n        else:\n            x = self.find_par(self.node2par[x])\n            return x\n    \n    def unite(self, x, y):\n        x, y = self.find_par(x), self.find_par(y)\n        if x==y:\n            return -1\n        if self.rank[x]<self.rank[y]:\n            self.node2par[x] = y\n        else:\n            self.node2par[y] = x\n        if self.rank[x]==self.rank[y]:\n            self.rank[x]+=1\n        self.count -= 1\n        \nclass Solution:\n    def findRedundantConnection(self, edges):\n        N = len(edges)\n        uf = UnionFind(N)\n        for e in edges:\n            a, b = e[0], e[1]\n            res = uf.unite(a,b)\n            if res==-1:\n                return e\n            ","compare_result":"111111111111111111111111111111111111111","title_slug":"redundant-connection"}