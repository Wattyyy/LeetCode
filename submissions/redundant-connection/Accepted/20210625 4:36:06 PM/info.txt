{"id":512918607,"lang":"python3","time":"2 weeks, 4 days","timestamp":1624606566,"status_display":"Accepted","runtime":"56 ms","url":"/submissions/detail/512918607/","is_pending":"Not Pending","title":"Redundant Connection","memory":"15.1 MB","code":"\nfrom typing import List\n\nclass UnionFind:\n    def __init__(self, N):\n        self.node2par = {i:i for i in range(1, N+1)}\n        self.rank = {i:0 for i in range(1, N+1)}\n\n    def find_par(self, x):\n        if self.node2par[x] != x:\n            x = self.find_par(self.node2par[x])\n        return x\n\n    def unite(self, x, y):\n        x, y = self.find_par(x), self.find_par(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.node2par[x] = y\n        else:\n            self.node2par[y] = x\n        if self.rank[x] == self.rank[y]:\n            self.rank[x] += 1\n        \n        \nclass Solution:\n    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n        n = len(edges)\n        uf = UnionFind(n)\n        for u, v in edges:\n            if uf.find_par(u) != uf.find_par(v):\n                uf.unite(u, v)\n            else:\n                return [u, v]\n\n        ","compare_result":"111111111111111111111111111111111111111","title_slug":"redundant-connection"}